import{r as g,R as T,j as C}from"./index-ca264629.js";const z=Object.getPrototypeOf(async function(){}).constructor;function q(){}let a=q;const _=0,I=1,A=2,O=3,P=4,L=5,N=6,U=7,S=8;function y(c){switch(c){case _:return"NOT_SET";case I:return"NOTIFY_KEY";case A:return"NOTIFY_RESIZE";case O:return"NOTIFY_OPEN_FILE_BUF_COMPLETE";case P:return"NOTIFY_CLIPBOARD_WRITE_COMPLETE";case L:return"REQUEST_CMDLINE";case N:return"REQUEST_SHARED_BUF";case U:return"NOTIFY_ERROR_OUTPUT";case S:return"STATUS_NOTIFY_EVAL_FUNC_RET";default:return`Unknown command: ${c}`}}class W{constructor(e,t,r){this.worker=new Worker(e),this.worker.onmessage=this.recvMessage.bind(this),this.worker.onerror=this.recvError.bind(this),this.sharedBuffer=new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT*128)),this.onMessage=t,this.onError=r,this.onOneshotMessage=new Map,this.debug=!1,this.pendingEvents=[]}terminate(){this.worker.terminate(),this.worker.onmessage=null,a("Terminated worker thread. Thank you for working hard!")}sendStartMessage(e){this.worker.postMessage(e),a("Sent start message",e)}notifyOpenFileBufComplete(e,t){this.enqueueEvent(O,t,e)}notifyClipboardWriteComplete(e,t){this.enqueueEvent(P,e,t)}notifyKeyEvent(e,t,r,i,n,s){this.enqueueEvent(I,t,r,i,n,s,e)}notifyResizeEvent(e,t){this.enqueueEvent(A,e,t)}async requestSharedBuffer(e){this.enqueueEvent(N,e);const t=await this.waitForOneshotMessage("shared-buf:response");if(t.buffer.byteLength!==e)throw new Error(`Size of shared buffer from worker ${t.buffer.byteLength} bytes mismatches to requested size ${e} bytes`);return[t.bufId,t.buffer]}notifyClipboardError(){this.notifyClipboardWriteComplete(!0,0),a("Reading clipboard failed. Notify it to worker")}async responseClipboardText(e){const t=new TextEncoder().encode(e),[r,i]=await this.requestSharedBuffer(t.byteLength+1);new Uint8Array(i).set(t),this.notifyClipboardWriteComplete(!1,r),a("Wrote clipboard",t.byteLength,"bytes text and notified to worker")}async requestCmdline(e){if(e.length===0)throw new Error("Specified command line is empty");this.enqueueEvent(L,e);const t=await this.waitForOneshotMessage("cmdline:response");if(a("Result of command",e,":",t.success),!t.success)throw Error(`Command '${e}' was invalid and not accepted by Vim`)}async notifyErrorOutput(e){const t=new TextEncoder().encode(e),[r,i]=await this.requestSharedBuffer(t.byteLength);new Uint8Array(i).set(t),this.enqueueEvent(U,r),a("Sent error message output:",e)}async notifyEvalFuncRet(e){const t=new TextEncoder().encode(e),[r,i]=await this.requestSharedBuffer(t.byteLength);new Uint8Array(i).set(t),this.enqueueEvent(S,!1,r),a("Sent return value of evaluated JS function:",e)}async notifyEvalFuncError(e,t,r){const i=`${e} for jsevalfunc(): ${t.message}: ${t.stack}`;if(r)return a("Will send error output from jsevalfunc() though the invocation was notify-only:",i),this.notifyErrorOutput(i);const n=new TextEncoder().encode("E9999: "+i),[s,o]=await this.requestSharedBuffer(n.byteLength);new Uint8Array(o).set(n),this.enqueueEvent(S,!0,s),a("Sent exception thrown by evaluated JS function:",e,t)}onEventDone(e){const t=y(e),r=this.pendingEvents.shift();if(r===void 0)throw new Error(`FATAL: Received ${t} event but event queue is empty`);if(r[0]!==e)throw new Error(`FATAL: Received ${t} event but queue says previous event was ${y(r[0])} with args ${r[1]}`);if(this.pendingEvents.length===0){a("No pending event remains after event",t);return}a("After",t,"event, still",this.pendingEvents.length,"events are pending");const[i,n]=this.pendingEvents[0];this.sendEvent(i,n)}enqueueEvent(e,...t){if(this.pendingEvents.push([e,t]),this.pendingEvents.length>1){a("Other event is being handled by worker. Pending:",y(e),t);return}this.sendEvent(e,t)}sendEvent(e,t){const r=y(e);this.debug&&Atomics.load(this.sharedBuffer,0)!==_&&console.error("INVARIANT ERROR! Status byte must be zero cleared:",r),a("Write event",r,"payload to buffer:",t);let i=0;this.sharedBuffer[i++]=e;for(const n of t)switch(typeof n){case"string":i=this.encodeStringToBuffer(n,i);break;case"number":this.sharedBuffer[i++]=n;break;case"boolean":this.sharedBuffer[i++]=+n;break;default:throw new Error(`FATAL: Invalid value for payload to worker: ${n}`)}a("Wrote",i*4,"bytes to buffer for event",r),Atomics.notify(this.sharedBuffer,0,1),a("Notified event",r,"to worker")}async waitForOneshotMessage(e){return new Promise(t=>{this.onOneshotMessage.set(e,t)})}encodeStringToBuffer(e,t){let r=t;const i=e.length;this.sharedBuffer[r++]=i;for(let n=0;n<i;++n)this.sharedBuffer[r++]=e.charCodeAt(n);return r}recvMessage(e){const t=e.data,r=this.onOneshotMessage.get(t.kind);if(r!==void 0){this.onOneshotMessage.delete(t.kind),r(t);return}this.onMessage(t)}recvError(e){a("Received an error from worker:",e);const t=`${e.message} (${e.filename}:${e.lineno}:${e.colno})`;this.onError(new Error(t))}}class D{constructor(e,t,r,i){this.canvas=r,this.worker=i,this.elemHeight=t,this.elemWidth=e;const n=window.devicePixelRatio||1;this.canvas.width=e*n,this.canvas.height=t*n,this.bounceTimerToken=null,this.onResize=this.onResize.bind(this)}onVimInit(){window.addEventListener("resize",this.onResize,{passive:!0})}onVimExit(){window.removeEventListener("resize",this.onResize)}doResize(){const e=this.canvas.getBoundingClientRect();a("Resize Vim:",e),this.elemWidth=e.width,this.elemHeight=e.height;const t=window.devicePixelRatio||1;this.canvas.width=e.width*t,this.canvas.height=e.height*t,this.worker.notifyResizeEvent(e.width,e.height)}onResize(){this.bounceTimerToken!==null&&window.clearTimeout(this.bounceTimerToken),this.bounceTimerToken=window.setTimeout(()=>{this.bounceTimerToken=null,this.doResize()},500)}}class ${constructor(e,t){this.worker=e,this.elem=t,this.onKeydown=this.onKeydown.bind(this),this.onBlur=this.onBlur.bind(this),this.onFocus=this.onFocus.bind(this),this.focus()}setFont(e,t){this.elem.style.fontFamily=e,this.elem.style.fontSize=`${t}px`}focus(){this.elem.focus()}onVimInit(){this.elem.addEventListener("keydown",this.onKeydown,{capture:!0}),this.elem.addEventListener("blur",this.onBlur),this.elem.addEventListener("focus",this.onFocus)}onVimExit(){this.elem.removeEventListener("keydown",this.onKeydown),this.elem.removeEventListener("blur",this.onBlur),this.elem.removeEventListener("focus",this.onFocus)}onKeydown(e){e.preventDefault(),e.stopPropagation(),a("onKeydown():",e,e.key,e.keyCode);let t=e.key;const r=e.ctrlKey,i=e.shiftKey,n=e.altKey,s=e.metaKey;if(t.length>1&&(t==="Unidentified"||r&&t==="Control"||i&&t==="Shift"||n&&t==="Alt"||s&&t==="Meta")){a("Ignore key input",t);return}(t==="Â¥"||!i&&t==="|"&&e.code==="IntlYen")&&(t="\\"),this.worker.notifyKeyEvent(t,e.keyCode,r,i,n,s)}onFocus(){a("onFocus()")}onBlur(e){a("onBlur():",e),e.preventDefault()}}class Y{constructor(e,t,r){this.worker=e,this.canvas=t;const i=this.canvas.getContext("2d",{alpha:!1});if(i===null)throw new Error("Cannot get 2D context for <canvas>");this.ctx=i;const n=this.canvas.getBoundingClientRect(),s=window.devicePixelRatio||1;this.canvas.width=n.width*s,this.canvas.height=n.height*s,this.canvas.addEventListener("click",this.onClick.bind(this),{capture:!0,passive:!0}),this.input=new $(this.worker,r),this.resizer=new D(n.width,n.height,t,e),this.onAnimationFrame=this.onAnimationFrame.bind(this),this.queue=[],this.rafScheduled=!1,this.perf=!1,this.fgColor="",this.spColor="",this.fontName=""}onVimInit(){this.input.onVimInit(),this.resizer.onVimInit()}onVimExit(){this.input.onVimExit(),this.resizer.onVimExit()}draw(e){this.rafScheduled||(window.requestAnimationFrame(this.onAnimationFrame),this.rafScheduled=!0),this.queue.push(e)}focus(){this.input.focus()}getDomSize(){return{width:this.resizer.elemWidth,height:this.resizer.elemHeight}}setPerf(e){this.perf=e}setColorFG(e){this.fgColor=e}setColorBG(e){}setColorSP(e){this.spColor=e}setFont(e,t){this.fontName=e,this.input.setFont(e,t)}drawRect(e,t,r,i,n,s){const o=window.devicePixelRatio||1;e=Math.floor(e*o),t=Math.floor(t*o),r=Math.floor(r*o),i=Math.floor(i*o),this.ctx.fillStyle=n,s?this.ctx.fillRect(e,t,r,i):this.ctx.rect(e,t,r,i)}drawText(e,t,r,i,n,s,o,u,h,m){const f=window.devicePixelRatio||1;t=t*f,r=r*f,i=i*f,n=n*f,s=s*f;let w=`${Math.floor(t)}px ${this.fontName}`;o&&(w="bold "+w),this.ctx.font=w,this.ctx.textBaseline="bottom",this.ctx.fillStyle=this.fgColor;const v=(r-t)/2,k=Math.floor(s+r-v);for(let l=0;l<e.length;++l){const E=e[l];E!==" "&&this.ctx.fillText(E,Math.floor(n+i*l),k)}if(u){this.ctx.strokeStyle=this.fgColor,this.ctx.lineWidth=1*f,this.ctx.setLineDash([]),this.ctx.beginPath();const l=Math.floor(s+r-v-1*f);this.ctx.moveTo(Math.floor(n),l),this.ctx.lineTo(Math.floor(n+i*e.length),l),this.ctx.stroke()}else if(h){this.ctx.strokeStyle=this.spColor,this.ctx.lineWidth=1*f;const l=Math.floor(i/3);this.ctx.setLineDash([l,l]),this.ctx.beginPath();const E=Math.floor(s+r-v-1*f);this.ctx.moveTo(Math.floor(n),E),this.ctx.lineTo(Math.floor(n+i*e.length),E),this.ctx.stroke()}else if(m){this.ctx.strokeStyle=this.fgColor,this.ctx.lineWidth=1*f,this.ctx.beginPath();const l=Math.floor(s+r/2);this.ctx.moveTo(Math.floor(n),l),this.ctx.lineTo(Math.floor(n+i*e.length),l),this.ctx.stroke()}}invertRect(e,t,r,i){const n=window.devicePixelRatio||1;e=Math.floor(e*n),t=Math.floor(t*n),r=Math.floor(r*n),i=Math.floor(i*n);const s=this.ctx.getImageData(e,t,r,i),o=s.data,u=o.length;for(let h=0;h<u;++h)o[h]=255-o[h],++h,o[h]=255-o[h],++h,o[h]=255-o[h],++h;this.ctx.putImageData(s,e,t)}imageScroll(e,t,r,i,n){const s=window.devicePixelRatio||1;e=Math.floor(e*s),t=Math.floor(t*s),r=Math.floor(r*s),i=Math.floor(i*s),n=Math.floor(n*s),this.ctx.drawImage(this.canvas,e,t,i,n,e,r,i,n)}onClick(){this.input.focus()}onAnimationFrame(){a("Rendering",this.queue.length,"events on animation frame"),this.perfMark("raf");for(const[e,t]of this.queue)this.perfMark("draw"),this[e].apply(this,t),this.perfMeasure("draw",`draw:${e}`);this.queue.length=0,this.rafScheduled=!1,this.perfMeasure("raf")}perfMark(e){this.perf&&performance.mark(e)}perfMeasure(e,t){this.perf&&(performance.measure(t??e,e),performance.clearMarks(e))}}class K{constructor(e){const t=e.workerScriptPath;if(!t)throw new Error("'workerScriptPath' option is required");if(this.handleError=this.handleError.bind(this),this.worker=new W(t,this.onMessage.bind(this),this.handleError),"canvas"in e&&"input"in e)this.screen=new Y(this.worker,e.canvas,e.input);else if("screen"in e)this.screen=e.screen;else throw new Error("Invalid options for VimWasm construction: "+JSON.stringify(e));this.perf=!1,this.debug=!1,this.perfMessages={},this.running=!1,this.end=!1}start(e){var t,r,i,n,s;if(this.running||this.end)throw new Error("Cannot start Vim twice");const o=e??{clipboard:navigator.clipboard!==void 0};o.debug&&(a=console.log.bind(console,"main:"),this.worker.debug=!0),this.perf=!!o.perf,this.debug=!!o.debug,this.screen.setPerf(this.perf),this.running=!0,this.perfMark("init");const{width:u,height:h}=this.screen.getDomSize(),m={kind:"start",buffer:this.worker.sharedBuffer,canvasDomWidth:u,canvasDomHeight:h,debug:this.debug,perf:this.perf,clipboard:!!o.clipboard,files:(t=o.files,t??{}),dirs:(r=o.dirs,r??[]),fetchFiles:(i=o.fetchFiles,i??{}),persistent:(n=o.persistentDirs,n??[]),cmdArgs:(s=o.cmdArgs,s??[])};this.worker.sendStartMessage(m),a("Started with drawer",this.screen)}async dropFile(e,t){if(!this.running)throw new Error("Cannot open file since Vim is not running");a("Handling to open file",e,t);const[r,i]=await this.worker.requestSharedBuffer(t.byteLength);new Uint8Array(i).set(new Uint8Array(t)),this.worker.notifyOpenFileBufComplete(e,r),a("Wrote file",e,"to",t.byteLength,"bytes buffer and notified it to worker")}async dropFiles(e){const t=new FileReader;for(const r of e){const[i,n]=await this.readFile(t,r);await this.dropFile(i,n)}}resize(e,t){this.worker.notifyResizeEvent(e,t)}sendKeydown(e,t,r){const{ctrl:i=!1,shift:n=!1,alt:s=!1,meta:o=!1}=r??{};if(e.length>1&&(e==="Unidentified"||i&&e==="Control"||n&&e==="Shift"||s&&e==="Alt"||o&&e==="Meta")){a("Ignore key input",e);return}this.worker.notifyKeyEvent(e,t,i,n,s,o)}cmdline(e){return this.worker.requestCmdline(e)}isRunning(){return this.running}focus(){this.screen.focus()}showError(e){return this.worker.notifyErrorOutput(e)}async readFile(e,t){return new Promise((r,i)=>{e.onload=n=>{a("Read file",t.name,"from D&D:",n),r([t.name,e.result])},e.onerror=()=>{e.abort(),i(new Error(`Error on loading file ${t}`))},e.readAsArrayBuffer(t)})}async evalJS(e,t){a("Evaluating JavaScript file",e,"with size",t.byteLength,"bytes");const i='"use strict";'+new TextDecoder().decode(t);try{Function(i)()}catch(n){a("Failed to evaluate",e,"with error:",n),await this.showError(`${n.message}

${n.stack}`)}}async evalFunc(e,t,r){a("Evaluating JavaScript function:",e,t);let i;try{i=new z(e)}catch(o){return this.worker.notifyEvalFuncError("Could not construct function",o,r)}let n;try{n=await i(...t)}catch(o){return this.worker.notifyEvalFuncError("Exception was thrown while evaluating function",o,r)}if(r)return a("Evaluated JavaScript result was discarded since the message was notify-only:",n,e),Promise.resolve();let s;try{s=JSON.stringify(n)}catch(o){return this.worker.notifyEvalFuncError("Could not serialize return value as JSON from function",o,!1)}return this.worker.notifyEvalFuncRet(s)}onMessage(e){if(this.perf&&e.timestamp!==void 0){const t=Date.now()-e.timestamp,r=e.kind==="draw"?`draw:${e.event[0]}`:e.kind;this.perfMessages[r]===void 0?this.perfMessages[r]=[t]:this.perfMessages[r].push(t)}switch(e.kind){case"draw":this.screen.draw(e.event),a("draw event",e.event);break;case"done":this.worker.onEventDone(e.status);break;case"evalfunc":{const t=e.argsJson===void 0?[]:JSON.parse(e.argsJson);this.evalFunc(e.body,t,e.notifyOnly).catch(this.handleError);break}case"title":this.onTitleUpdate&&(a("title was updated:",e.title),this.onTitleUpdate(e.title));break;case"read-clipboard:request":this.readClipboard?this.readClipboard().then(t=>this.worker.responseClipboardText(t)).catch(t=>{a("Cannot read clipboard:",t),this.worker.notifyClipboardError()}):(a("Cannot read clipboard because VimWasm.readClipboard is not set"),this.worker.notifyClipboardError());break;case"write-clipboard":a("Handle writing text",e.text,"to clipboard with",this.onWriteClipboard),this.onWriteClipboard&&this.onWriteClipboard(e.text);break;case"export":this.onFileExport!==void 0&&(a("Exporting file",e.path,"with size in bytes",e.contents.byteLength),this.onFileExport(e.path,e.contents));break;case"eval":this.evalJS(e.path,e.contents).catch(this.handleError);break;case"started":this.screen.onVimInit(),this.onVimInit&&this.onVimInit(),this.perfMeasure("init"),a("Vim started");break;case"exit":this.screen.onVimExit(),this.printPerfs(),this.worker.terminate(),this.onVimExit&&this.onVimExit(e.status),a("Vim exited with status",e.status),this.perf=!1,this.debug=!1,this.screen.setPerf(!1),this.running=!1,this.end=!0;break;case"error":a("Vim threw an error:",e.message),this.handleError(new Error(e.message)),this.worker.terminate();break;default:throw new Error(`Unexpected message from worker: ${JSON.stringify(e)}`)}}handleError(e){this.onError&&this.onError(e)}printPerfs(){if(this.perf){{const e=new Map;for(const n of performance.getEntries()){const s=e.get(n.name);s===void 0?e.set(n.name,[n]):s.push(n)}const t={},r={},i=[];for(const[n,s]of e){if(s.length===1&&s[0].entryType!=="measure"){i.push(s[0]);continue}console.log(`%c${n}`,"color: green; font-size: large"),console.table(s,["duration","startTime"]);const o=s.reduce((u,h)=>u+h.duration,0);t[n]=o/s.length,r[n]=o}console.log("%cTimings (ms)","color: green; font-size: large"),console.table(i,["name","entryType","startTime","duration"]),console.log("%cAmount: Perf Mark Durations (ms)","color: green; font-size: large"),console.table(r),console.log("%cAverage: Perf Mark Durations (ms)","color: green; font-size: large"),console.table(t),performance.clearMarks(),performance.clearMeasures()}{const e={};for(const t of Object.keys(this.perfMessages)){const r=this.perfMessages[t],i=r.reduce((n,s)=>n+s,0);e[t]=i/r.length}console.log("%cAverage: Inter-thread Messages Duration (ms)","color: green; font-size: large"),console.table(e),this.perfMessages={}}}}perfMark(e){this.perf&&performance.mark(e)}perfMeasure(e){this.perf&&(performance.measure(e,e),performance.clearMarks(e))}}function J({worker:c,drawer:e,debug:t,perf:r,clipboard:i,onVimExit:n,onVimInit:s,onFileExport:o,readClipboard:u,onWriteClipboard:h,onError:m,onTitleUpdate:f,files:w,fetchFiles:v,dirs:k,persistentDirs:l,cmdArgs:E,onVimCreated:M}){const b=g.useRef(null),x=g.useRef(null),[F,V]=g.useState(null);return g.useEffect(()=>{const B=e!==void 0?{workerScriptPath:c,screen:e}:{workerScriptPath:c,canvas:b.current,input:x.current},d=new K(B);return d.onVimInit=s,d.onVimExit=n,d.onFileExport=o,d.readClipboard=u,d.onWriteClipboard=h,d.onTitleUpdate=f,d.onError=m,b.current!==null&&(b.current.addEventListener("dragover",p=>{p.stopPropagation(),p.preventDefault(),p.dataTransfer&&(p.dataTransfer.dropEffect="copy")},!1),b.current.addEventListener("drop",p=>{p.stopPropagation(),p.preventDefault(),p.dataTransfer&&d.dropFiles(p.dataTransfer.files).catch(m)},!1)),M!==void 0&&M(d),d.start({debug:t,perf:r,clipboard:i,files:w,fetchFiles:v,dirs:k,persistentDirs:l,cmdArgs:E}),V(d),()=>{d.isRunning()&&d.cmdline("qall!")}},[c,t,r,i,w,k,l,E]),e!==void 0?[null,null,F]:[b,x,F]}const H={width:"1px",color:"transparent",backgroundColor:"transparent",padding:"0px",border:"0px",outline:"none",position:"relative",top:"0px",left:"0px"},j=c=>{const[e,t,r]=J(c);if(e===null||t===null)return null;const{style:i,className:n,id:s,onVimExit:o,onVimInit:u,onFileExport:h,onWriteClipboard:m,onError:f,readClipboard:w}=c;return r!==null&&(r.onVimExit=o,r.onVimInit=u,r.onFileExport=h,r.onWriteClipboard=m,r.onError=f,r.readClipboard=w),g.createElement(g.Fragment,null,g.createElement("canvas",{ref:e,style:i,className:n,id:s}),g.createElement("input",{ref:t,style:H,autoComplete:"off",autoFocus:!0}))},Q=""+new URL("vim-b27d49a7.js",import.meta.url).href,G="_container_poa9v_1",Z="_canvas_poa9v_15",R={container:G,canvas:Z};function re({contents:c,filename:e}){const t=T.useMemo(()=>["/work"],[]);e=ee(e),console.log(e);const r=`/work/${e}`,i=T.useMemo(()=>({[r]:c,"/home/web_user/.vim/vimrc":X}),[c,r]),n=T.useMemo(()=>[r],[r]);return C("div",{className:R.container,children:C(j,{className:R.canvas,cmdArgs:n,dirs:t,files:i,onError:console.error,onWriteClipboard:navigator.clipboard&&navigator.clipboard.writeText,readClipboard:navigator.clipboard&&navigator.clipboard.readText,worker:Q})})}const X=`
set guifont=Monaco:h14
colorscheme onedark
set number
set expandtab
set tabstop=2 shiftwidth=2 softtabstop=2
syntax enable
`.trim();function ee(c){return c.slice(c.lastIndexOf("/")+1)}export{re as default};
