import{r as g,R as y,j as S,F as W}from"./index-22fdf6b4.js";const q=Object.getPrototypeOf(async function(){}).constructor;function D(){}let a=D;const A=0,I=1,O=2,P=3,B=4,L=5,N=6,U=7,M=8;function T(c){switch(c){case A:return"NOT_SET";case I:return"NOTIFY_KEY";case O:return"NOTIFY_RESIZE";case P:return"NOTIFY_OPEN_FILE_BUF_COMPLETE";case B:return"NOTIFY_CLIPBOARD_WRITE_COMPLETE";case L:return"REQUEST_CMDLINE";case N:return"REQUEST_SHARED_BUF";case U:return"NOTIFY_ERROR_OUTPUT";case M:return"STATUS_NOTIFY_EVAL_FUNC_RET";default:return`Unknown command: ${c}`}}function $(){function c(e){return`${e} is not supported by this browser. If you're using Firefox or Safari, please enable feature flag.`}if(typeof SharedArrayBuffer>"u")return c("SharedArrayBuffer");if(typeof Atomics>"u")return c("Atomics API")}class Y{constructor(e,t,r){this.worker=new Worker(e),this.worker.onmessage=this.recvMessage.bind(this),this.worker.onerror=this.recvError.bind(this),this.sharedBuffer=new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT*128)),this.onMessage=t,this.onError=r,this.onOneshotMessage=new Map,this.debug=!1,this.pendingEvents=[]}terminate(){this.worker.terminate(),this.worker.onmessage=null,a("Terminated worker thread. Thank you for working hard!")}sendStartMessage(e){this.worker.postMessage(e),a("Sent start message",e)}notifyOpenFileBufComplete(e,t){this.enqueueEvent(P,t,e)}notifyClipboardWriteComplete(e,t){this.enqueueEvent(B,e,t)}notifyKeyEvent(e,t,r,n,i,s){this.enqueueEvent(I,t,r,n,i,s,e)}notifyResizeEvent(e,t){this.enqueueEvent(O,e,t)}async requestSharedBuffer(e){this.enqueueEvent(N,e);const t=await this.waitForOneshotMessage("shared-buf:response");if(t.buffer.byteLength!==e)throw new Error(`Size of shared buffer from worker ${t.buffer.byteLength} bytes mismatches to requested size ${e} bytes`);return[t.bufId,t.buffer]}notifyClipboardError(){this.notifyClipboardWriteComplete(!0,0),a("Reading clipboard failed. Notify it to worker")}async responseClipboardText(e){const t=new TextEncoder().encode(e),[r,n]=await this.requestSharedBuffer(t.byteLength+1);new Uint8Array(n).set(t),this.notifyClipboardWriteComplete(!1,r),a("Wrote clipboard",t.byteLength,"bytes text and notified to worker")}async requestCmdline(e){if(e.length===0)throw new Error("Specified command line is empty");this.enqueueEvent(L,e);const t=await this.waitForOneshotMessage("cmdline:response");if(a("Result of command",e,":",t.success),!t.success)throw Error(`Command '${e}' was invalid and not accepted by Vim`)}async notifyErrorOutput(e){const t=new TextEncoder().encode(e),[r,n]=await this.requestSharedBuffer(t.byteLength);new Uint8Array(n).set(t),this.enqueueEvent(U,r),a("Sent error message output:",e)}async notifyEvalFuncRet(e){const t=new TextEncoder().encode(e),[r,n]=await this.requestSharedBuffer(t.byteLength);new Uint8Array(n).set(t),this.enqueueEvent(M,!1,r),a("Sent return value of evaluated JS function:",e)}async notifyEvalFuncError(e,t,r){const n=`${e} for jsevalfunc(): ${t.message}: ${t.stack}`;if(r)return a("Will send error output from jsevalfunc() though the invocation was notify-only:",n),this.notifyErrorOutput(n);const i=new TextEncoder().encode("E9999: "+n),[s,o]=await this.requestSharedBuffer(i.byteLength);new Uint8Array(o).set(i),this.enqueueEvent(M,!0,s),a("Sent exception thrown by evaluated JS function:",e,t)}onEventDone(e){const t=T(e),r=this.pendingEvents.shift();if(r===void 0)throw new Error(`FATAL: Received ${t} event but event queue is empty`);if(r[0]!==e)throw new Error(`FATAL: Received ${t} event but queue says previous event was ${T(r[0])} with args ${r[1]}`);if(this.pendingEvents.length===0){a("No pending event remains after event",t);return}a("After",t,"event, still",this.pendingEvents.length,"events are pending");const[n,i]=this.pendingEvents[0];this.sendEvent(n,i)}enqueueEvent(e,...t){if(this.pendingEvents.push([e,t]),this.pendingEvents.length>1){a("Other event is being handled by worker. Pending:",T(e),t);return}this.sendEvent(e,t)}sendEvent(e,t){const r=T(e);this.debug&&Atomics.load(this.sharedBuffer,0)!==A&&console.error("INVARIANT ERROR! Status byte must be zero cleared:",r),a("Write event",r,"payload to buffer:",t);let n=0;this.sharedBuffer[n++]=e;for(const i of t)switch(typeof i){case"string":n=this.encodeStringToBuffer(i,n);break;case"number":this.sharedBuffer[n++]=i;break;case"boolean":this.sharedBuffer[n++]=+i;break;default:throw new Error(`FATAL: Invalid value for payload to worker: ${i}`)}a("Wrote",n*4,"bytes to buffer for event",r),Atomics.notify(this.sharedBuffer,0,1),a("Notified event",r,"to worker")}async waitForOneshotMessage(e){return new Promise(t=>{this.onOneshotMessage.set(e,t)})}encodeStringToBuffer(e,t){let r=t;const n=e.length;this.sharedBuffer[r++]=n;for(let i=0;i<n;++i)this.sharedBuffer[r++]=e.charCodeAt(i);return r}recvMessage(e){const t=e.data,r=this.onOneshotMessage.get(t.kind);if(r!==void 0){this.onOneshotMessage.delete(t.kind),r(t);return}this.onMessage(t)}recvError(e){a("Received an error from worker:",e);const t=`${e.message} (${e.filename}:${e.lineno}:${e.colno})`;this.onError(new Error(t))}}class K{constructor(e,t,r,n){this.canvas=r,this.worker=n,this.elemHeight=t,this.elemWidth=e;const i=window.devicePixelRatio||1;this.canvas.width=e*i,this.canvas.height=t*i,this.bounceTimerToken=null,this.onResize=this.onResize.bind(this)}onVimInit(){window.addEventListener("resize",this.onResize,{passive:!0})}onVimExit(){window.removeEventListener("resize",this.onResize)}doResize(){const e=this.canvas.getBoundingClientRect();a("Resize Vim:",e),this.elemWidth=e.width,this.elemHeight=e.height;const t=window.devicePixelRatio||1;this.canvas.width=e.width*t,this.canvas.height=e.height*t,this.worker.notifyResizeEvent(e.width,e.height)}onResize(){this.bounceTimerToken!==null&&window.clearTimeout(this.bounceTimerToken),this.bounceTimerToken=window.setTimeout(()=>{this.bounceTimerToken=null,this.doResize()},500)}}class J{constructor(e,t){this.worker=e,this.elem=t,this.onKeydown=this.onKeydown.bind(this),this.onBlur=this.onBlur.bind(this),this.onFocus=this.onFocus.bind(this),this.focus()}setFont(e,t){this.elem.style.fontFamily=e,this.elem.style.fontSize=`${t}px`}focus(){this.elem.focus()}onVimInit(){this.elem.addEventListener("keydown",this.onKeydown,{capture:!0}),this.elem.addEventListener("blur",this.onBlur),this.elem.addEventListener("focus",this.onFocus)}onVimExit(){this.elem.removeEventListener("keydown",this.onKeydown),this.elem.removeEventListener("blur",this.onBlur),this.elem.removeEventListener("focus",this.onFocus)}onKeydown(e){e.preventDefault(),e.stopPropagation(),a("onKeydown():",e,e.key,e.keyCode);let t=e.key;const r=e.ctrlKey,n=e.shiftKey,i=e.altKey,s=e.metaKey;if(t.length>1&&(t==="Unidentified"||r&&t==="Control"||n&&t==="Shift"||i&&t==="Alt"||s&&t==="Meta")){a("Ignore key input",t);return}(t==="Â¥"||!n&&t==="|"&&e.code==="IntlYen")&&(t="\\"),this.worker.notifyKeyEvent(t,e.keyCode,r,n,i,s)}onFocus(){a("onFocus()")}onBlur(e){a("onBlur():",e),e.preventDefault()}}class j{constructor(e,t,r){this.worker=e,this.canvas=t;const n=this.canvas.getContext("2d",{alpha:!1});if(n===null)throw new Error("Cannot get 2D context for <canvas>");this.ctx=n;const i=this.canvas.getBoundingClientRect(),s=window.devicePixelRatio||1;this.canvas.width=i.width*s,this.canvas.height=i.height*s,this.canvas.addEventListener("click",this.onClick.bind(this),{capture:!0,passive:!0}),this.input=new J(this.worker,r),this.resizer=new K(i.width,i.height,t,e),this.onAnimationFrame=this.onAnimationFrame.bind(this),this.queue=[],this.rafScheduled=!1,this.perf=!1,this.fgColor="",this.spColor="",this.fontName=""}onVimInit(){this.input.onVimInit(),this.resizer.onVimInit()}onVimExit(){this.input.onVimExit(),this.resizer.onVimExit()}draw(e){this.rafScheduled||(window.requestAnimationFrame(this.onAnimationFrame),this.rafScheduled=!0),this.queue.push(e)}focus(){this.input.focus()}getDomSize(){return{width:this.resizer.elemWidth,height:this.resizer.elemHeight}}setPerf(e){this.perf=e}setColorFG(e){this.fgColor=e}setColorBG(e){}setColorSP(e){this.spColor=e}setFont(e,t){this.fontName=e,this.input.setFont(e,t)}drawRect(e,t,r,n,i,s){const o=window.devicePixelRatio||1;e=Math.floor(e*o),t=Math.floor(t*o),r=Math.floor(r*o),n=Math.floor(n*o),this.ctx.fillStyle=i,s?this.ctx.fillRect(e,t,r,n):this.ctx.rect(e,t,r,n)}drawText(e,t,r,n,i,s,o,u,h,p){const l=window.devicePixelRatio||1;t=t*l,r=r*l,n=n*l,i=i*l,s=s*l;let m=`${Math.floor(t)}px ${this.fontName}`;o&&(m="bold "+m),this.ctx.font=m,this.ctx.textBaseline="bottom",this.ctx.fillStyle=this.fgColor;const v=(r-t)/2,k=Math.floor(s+r-v);for(let f=0;f<e.length;++f){const E=e[f];E!==" "&&this.ctx.fillText(E,Math.floor(i+n*f),k)}if(u){this.ctx.strokeStyle=this.fgColor,this.ctx.lineWidth=1*l,this.ctx.setLineDash([]),this.ctx.beginPath();const f=Math.floor(s+r-v-1*l);this.ctx.moveTo(Math.floor(i),f),this.ctx.lineTo(Math.floor(i+n*e.length),f),this.ctx.stroke()}else if(h){this.ctx.strokeStyle=this.spColor,this.ctx.lineWidth=1*l;const f=Math.floor(n/3);this.ctx.setLineDash([f,f]),this.ctx.beginPath();const E=Math.floor(s+r-v-1*l);this.ctx.moveTo(Math.floor(i),E),this.ctx.lineTo(Math.floor(i+n*e.length),E),this.ctx.stroke()}else if(p){this.ctx.strokeStyle=this.fgColor,this.ctx.lineWidth=1*l,this.ctx.beginPath();const f=Math.floor(s+r/2);this.ctx.moveTo(Math.floor(i),f),this.ctx.lineTo(Math.floor(i+n*e.length),f),this.ctx.stroke()}}invertRect(e,t,r,n){const i=window.devicePixelRatio||1;e=Math.floor(e*i),t=Math.floor(t*i),r=Math.floor(r*i),n=Math.floor(n*i);const s=this.ctx.getImageData(e,t,r,n),o=s.data,u=o.length;for(let h=0;h<u;++h)o[h]=255-o[h],++h,o[h]=255-o[h],++h,o[h]=255-o[h],++h;this.ctx.putImageData(s,e,t)}imageScroll(e,t,r,n,i){const s=window.devicePixelRatio||1;e=Math.floor(e*s),t=Math.floor(t*s),r=Math.floor(r*s),n=Math.floor(n*s),i=Math.floor(i*s),this.ctx.drawImage(this.canvas,e,t,n,i,e,r,n,i)}onClick(){this.input.focus()}onAnimationFrame(){a("Rendering",this.queue.length,"events on animation frame"),this.perfMark("raf");for(const[e,t]of this.queue)this.perfMark("draw"),this[e].apply(this,t),this.perfMeasure("draw",`draw:${e}`);this.queue.length=0,this.rafScheduled=!1,this.perfMeasure("raf")}perfMark(e){this.perf&&performance.mark(e)}perfMeasure(e,t){this.perf&&(performance.measure(t??e,e),performance.clearMarks(e))}}class H{constructor(e){const t=e.workerScriptPath;if(!t)throw new Error("'workerScriptPath' option is required");if(this.handleError=this.handleError.bind(this),this.worker=new Y(t,this.onMessage.bind(this),this.handleError),"canvas"in e&&"input"in e)this.screen=new j(this.worker,e.canvas,e.input);else if("screen"in e)this.screen=e.screen;else throw new Error("Invalid options for VimWasm construction: "+JSON.stringify(e));this.perf=!1,this.debug=!1,this.perfMessages={},this.running=!1,this.end=!1}start(e){var t,r,n,i,s;if(this.running||this.end)throw new Error("Cannot start Vim twice");const o=e??{clipboard:navigator.clipboard!==void 0};o.debug&&(a=console.log.bind(console,"main:"),this.worker.debug=!0),this.perf=!!o.perf,this.debug=!!o.debug,this.screen.setPerf(this.perf),this.running=!0,this.perfMark("init");const{width:u,height:h}=this.screen.getDomSize(),p={kind:"start",buffer:this.worker.sharedBuffer,canvasDomWidth:u,canvasDomHeight:h,debug:this.debug,perf:this.perf,clipboard:!!o.clipboard,files:(t=o.files,t??{}),dirs:(r=o.dirs,r??[]),fetchFiles:(n=o.fetchFiles,n??{}),persistent:(i=o.persistentDirs,i??[]),cmdArgs:(s=o.cmdArgs,s??[])};this.worker.sendStartMessage(p),a("Started with drawer",this.screen)}async dropFile(e,t){if(!this.running)throw new Error("Cannot open file since Vim is not running");a("Handling to open file",e,t);const[r,n]=await this.worker.requestSharedBuffer(t.byteLength);new Uint8Array(n).set(new Uint8Array(t)),this.worker.notifyOpenFileBufComplete(e,r),a("Wrote file",e,"to",t.byteLength,"bytes buffer and notified it to worker")}async dropFiles(e){const t=new FileReader;for(const r of e){const[n,i]=await this.readFile(t,r);await this.dropFile(n,i)}}resize(e,t){this.worker.notifyResizeEvent(e,t)}sendKeydown(e,t,r){const{ctrl:n=!1,shift:i=!1,alt:s=!1,meta:o=!1}=r??{};if(e.length>1&&(e==="Unidentified"||n&&e==="Control"||i&&e==="Shift"||s&&e==="Alt"||o&&e==="Meta")){a("Ignore key input",e);return}this.worker.notifyKeyEvent(e,t,n,i,s,o)}cmdline(e){return this.worker.requestCmdline(e)}isRunning(){return this.running}focus(){this.screen.focus()}showError(e){return this.worker.notifyErrorOutput(e)}async readFile(e,t){return new Promise((r,n)=>{e.onload=i=>{a("Read file",t.name,"from D&D:",i),r([t.name,e.result])},e.onerror=()=>{e.abort(),n(new Error(`Error on loading file ${t}`))},e.readAsArrayBuffer(t)})}async evalJS(e,t){a("Evaluating JavaScript file",e,"with size",t.byteLength,"bytes");const n='"use strict";'+new TextDecoder().decode(t);try{Function(n)()}catch(i){a("Failed to evaluate",e,"with error:",i),await this.showError(`${i.message}

${i.stack}`)}}async evalFunc(e,t,r){a("Evaluating JavaScript function:",e,t);let n;try{n=new q(e)}catch(o){return this.worker.notifyEvalFuncError("Could not construct function",o,r)}let i;try{i=await n(...t)}catch(o){return this.worker.notifyEvalFuncError("Exception was thrown while evaluating function",o,r)}if(r)return a("Evaluated JavaScript result was discarded since the message was notify-only:",i,e),Promise.resolve();let s;try{s=JSON.stringify(i)}catch(o){return this.worker.notifyEvalFuncError("Could not serialize return value as JSON from function",o,!1)}return this.worker.notifyEvalFuncRet(s)}onMessage(e){if(this.perf&&e.timestamp!==void 0){const t=Date.now()-e.timestamp,r=e.kind==="draw"?`draw:${e.event[0]}`:e.kind;this.perfMessages[r]===void 0?this.perfMessages[r]=[t]:this.perfMessages[r].push(t)}switch(e.kind){case"draw":this.screen.draw(e.event),a("draw event",e.event);break;case"done":this.worker.onEventDone(e.status);break;case"evalfunc":{const t=e.argsJson===void 0?[]:JSON.parse(e.argsJson);this.evalFunc(e.body,t,e.notifyOnly).catch(this.handleError);break}case"title":this.onTitleUpdate&&(a("title was updated:",e.title),this.onTitleUpdate(e.title));break;case"read-clipboard:request":this.readClipboard?this.readClipboard().then(t=>this.worker.responseClipboardText(t)).catch(t=>{a("Cannot read clipboard:",t),this.worker.notifyClipboardError()}):(a("Cannot read clipboard because VimWasm.readClipboard is not set"),this.worker.notifyClipboardError());break;case"write-clipboard":a("Handle writing text",e.text,"to clipboard with",this.onWriteClipboard),this.onWriteClipboard&&this.onWriteClipboard(e.text);break;case"export":this.onFileExport!==void 0&&(a("Exporting file",e.path,"with size in bytes",e.contents.byteLength),this.onFileExport(e.path,e.contents));break;case"eval":this.evalJS(e.path,e.contents).catch(this.handleError);break;case"started":this.screen.onVimInit(),this.onVimInit&&this.onVimInit(),this.perfMeasure("init"),a("Vim started");break;case"exit":this.screen.onVimExit(),this.printPerfs(),this.worker.terminate(),this.onVimExit&&this.onVimExit(e.status),a("Vim exited with status",e.status),this.perf=!1,this.debug=!1,this.screen.setPerf(!1),this.running=!1,this.end=!0;break;case"error":a("Vim threw an error:",e.message),this.handleError(new Error(e.message)),this.worker.terminate();break;default:throw new Error(`Unexpected message from worker: ${JSON.stringify(e)}`)}}handleError(e){this.onError&&this.onError(e)}printPerfs(){if(this.perf){{const e=new Map;for(const i of performance.getEntries()){const s=e.get(i.name);s===void 0?e.set(i.name,[i]):s.push(i)}const t={},r={},n=[];for(const[i,s]of e){if(s.length===1&&s[0].entryType!=="measure"){n.push(s[0]);continue}console.log(`%c${i}`,"color: green; font-size: large"),console.table(s,["duration","startTime"]);const o=s.reduce((u,h)=>u+h.duration,0);t[i]=o/s.length,r[i]=o}console.log("%cTimings (ms)","color: green; font-size: large"),console.table(n,["name","entryType","startTime","duration"]),console.log("%cAmount: Perf Mark Durations (ms)","color: green; font-size: large"),console.table(r),console.log("%cAverage: Perf Mark Durations (ms)","color: green; font-size: large"),console.table(t),performance.clearMarks(),performance.clearMeasures()}{const e={};for(const t of Object.keys(this.perfMessages)){const r=this.perfMessages[t],n=r.reduce((i,s)=>i+s,0);e[t]=n/r.length}console.log("%cAverage: Inter-thread Messages Duration (ms)","color: green; font-size: large"),console.table(e),this.perfMessages={}}}}perfMark(e){this.perf&&performance.mark(e)}perfMeasure(e){this.perf&&(performance.measure(e,e),performance.clearMarks(e))}}function Q({worker:c,drawer:e,debug:t,perf:r,clipboard:n,onVimExit:i,onVimInit:s,onFileExport:o,readClipboard:u,onWriteClipboard:h,onError:p,onTitleUpdate:l,files:m,fetchFiles:v,dirs:k,persistentDirs:f,cmdArgs:E,onVimCreated:x}){const b=g.useRef(null),F=g.useRef(null),[C,V]=g.useState(null);return g.useEffect(()=>{const z=e!==void 0?{workerScriptPath:c,screen:e}:{workerScriptPath:c,canvas:b.current,input:F.current},d=new H(z);return d.onVimInit=s,d.onVimExit=i,d.onFileExport=o,d.readClipboard=u,d.onWriteClipboard=h,d.onTitleUpdate=l,d.onError=p,b.current!==null&&(b.current.addEventListener("dragover",w=>{w.stopPropagation(),w.preventDefault(),w.dataTransfer&&(w.dataTransfer.dropEffect="copy")},!1),b.current.addEventListener("drop",w=>{w.stopPropagation(),w.preventDefault(),w.dataTransfer&&d.dropFiles(w.dataTransfer.files).catch(p)},!1)),x!==void 0&&x(d),d.start({debug:t,perf:r,clipboard:n,files:m,fetchFiles:v,dirs:k,persistentDirs:f,cmdArgs:E}),V(d),()=>{d.isRunning()&&d.cmdline("qall!")}},[c,t,r,n,m,k,f,E]),e!==void 0?[null,null,C]:[b,F,C]}const G={width:"1px",color:"transparent",backgroundColor:"transparent",padding:"0px",border:"0px",outline:"none",position:"relative",top:"0px",left:"0px"},Z=c=>{const[e,t,r]=Q(c);if(e===null||t===null)return null;const{style:n,className:i,id:s,onVimExit:o,onVimInit:u,onFileExport:h,onWriteClipboard:p,onError:l,readClipboard:m}=c;return r!==null&&(r.onVimExit=o,r.onVimInit=u,r.onFileExport=h,r.onWriteClipboard=p,r.onError=l,r.readClipboard=m),g.createElement(g.Fragment,null,g.createElement("canvas",{ref:e,style:n,className:i,id:s}),g.createElement("input",{ref:t,style:G,autoComplete:"off",autoFocus:!0}))},X=""+new URL("vim-b27d49a7.js",import.meta.url).href,ee="_container_pealx_1",te="_canvas_pealx_16",R={container:ee,canvas:te};function ie({filename:c,initialContents:e,onEdit:t}){const r=y.useMemo(()=>["/work"],[]);c=_(c);const n=`/work/${c}`,[i]=y.useState(e),s=y.useMemo(()=>({[n]:i,"/home/web_user/.vim/vimrc":re}),[i,n]),o=y.useMemo(()=>[n],[n]),u=y.useCallback((p,l)=>{const v=new TextDecoder("utf-8").decode(l);_(p)===c&&t(v)},[c,t]),h=$();return h?S(W,{children:h}):S("div",{className:R.container,children:S(Z,{className:R.canvas,cmdArgs:o,dirs:r,files:s,onError:console.error,onFileExport:u,onWriteClipboard:navigator.clipboard&&navigator.clipboard.writeText,readClipboard:navigator.clipboard&&navigator.clipboard.readText,worker:X})})}const re=`
set guifont=Monaco:h14
colorscheme onedark
set number
set expandtab
set tabstop=2 shiftwidth=2 softtabstop=2
syntax enable
autocmd BufWritePost * :export
imap jj <Esc>l
imap jk <Esc>l
`.trim();function _(c){return c.slice(c.lastIndexOf("/")+1)}export{ie as default};
