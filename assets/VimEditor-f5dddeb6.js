import{r as k,R as y,j as V,a as C}from"./index-0f1c4c38.js";const q=Object.getPrototypeOf(async function(){}).constructor;function D(){}let a=D;const x=0,A=1,I=2,O=3,P=4,z=5,B=6,L=7,M=8;function T(l){switch(l){case x:return"NOT_SET";case A:return"NOTIFY_KEY";case I:return"NOTIFY_RESIZE";case O:return"NOTIFY_OPEN_FILE_BUF_COMPLETE";case P:return"NOTIFY_CLIPBOARD_WRITE_COMPLETE";case z:return"REQUEST_CMDLINE";case B:return"REQUEST_SHARED_BUF";case L:return"NOTIFY_ERROR_OUTPUT";case M:return"STATUS_NOTIFY_EVAL_FUNC_RET";default:return`Unknown command: ${l}`}}class W{constructor(e,t,r){this.worker=new Worker(e),this.worker.onmessage=this.recvMessage.bind(this),this.worker.onerror=this.recvError.bind(this),this.sharedBuffer=new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT*128)),this.onMessage=t,this.onError=r,this.onOneshotMessage=new Map,this.debug=!1,this.pendingEvents=[]}terminate(){this.worker.terminate(),this.worker.onmessage=null,a("Terminated worker thread. Thank you for working hard!")}sendStartMessage(e){this.worker.postMessage(e),a("Sent start message",e)}notifyOpenFileBufComplete(e,t){this.enqueueEvent(O,t,e)}notifyClipboardWriteComplete(e,t){this.enqueueEvent(P,e,t)}notifyKeyEvent(e,t,r,n,i,s){this.enqueueEvent(A,t,r,n,i,s,e)}notifyResizeEvent(e,t){this.enqueueEvent(I,e,t)}async requestSharedBuffer(e){this.enqueueEvent(B,e);const t=await this.waitForOneshotMessage("shared-buf:response");if(t.buffer.byteLength!==e)throw new Error(`Size of shared buffer from worker ${t.buffer.byteLength} bytes mismatches to requested size ${e} bytes`);return[t.bufId,t.buffer]}notifyClipboardError(){this.notifyClipboardWriteComplete(!0,0),a("Reading clipboard failed. Notify it to worker")}async responseClipboardText(e){const t=new TextEncoder().encode(e),[r,n]=await this.requestSharedBuffer(t.byteLength+1);new Uint8Array(n).set(t),this.notifyClipboardWriteComplete(!1,r),a("Wrote clipboard",t.byteLength,"bytes text and notified to worker")}async requestCmdline(e){if(e.length===0)throw new Error("Specified command line is empty");this.enqueueEvent(z,e);const t=await this.waitForOneshotMessage("cmdline:response");if(a("Result of command",e,":",t.success),!t.success)throw Error(`Command '${e}' was invalid and not accepted by Vim`)}async notifyErrorOutput(e){const t=new TextEncoder().encode(e),[r,n]=await this.requestSharedBuffer(t.byteLength);new Uint8Array(n).set(t),this.enqueueEvent(L,r),a("Sent error message output:",e)}async notifyEvalFuncRet(e){const t=new TextEncoder().encode(e),[r,n]=await this.requestSharedBuffer(t.byteLength);new Uint8Array(n).set(t),this.enqueueEvent(M,!1,r),a("Sent return value of evaluated JS function:",e)}async notifyEvalFuncError(e,t,r){const n=`${e} for jsevalfunc(): ${t.message}: ${t.stack}`;if(r)return a("Will send error output from jsevalfunc() though the invocation was notify-only:",n),this.notifyErrorOutput(n);const i=new TextEncoder().encode("E9999: "+n),[s,o]=await this.requestSharedBuffer(i.byteLength);new Uint8Array(o).set(i),this.enqueueEvent(M,!0,s),a("Sent exception thrown by evaluated JS function:",e,t)}onEventDone(e){const t=T(e),r=this.pendingEvents.shift();if(r===void 0)throw new Error(`FATAL: Received ${t} event but event queue is empty`);if(r[0]!==e)throw new Error(`FATAL: Received ${t} event but queue says previous event was ${T(r[0])} with args ${r[1]}`);if(this.pendingEvents.length===0){a("No pending event remains after event",t);return}a("After",t,"event, still",this.pendingEvents.length,"events are pending");const[n,i]=this.pendingEvents[0];this.sendEvent(n,i)}enqueueEvent(e,...t){if(this.pendingEvents.push([e,t]),this.pendingEvents.length>1){a("Other event is being handled by worker. Pending:",T(e),t);return}this.sendEvent(e,t)}sendEvent(e,t){const r=T(e);this.debug&&Atomics.load(this.sharedBuffer,0)!==x&&console.error("INVARIANT ERROR! Status byte must be zero cleared:",r),a("Write event",r,"payload to buffer:",t);let n=0;this.sharedBuffer[n++]=e;for(const i of t)switch(typeof i){case"string":n=this.encodeStringToBuffer(i,n);break;case"number":this.sharedBuffer[n++]=i;break;case"boolean":this.sharedBuffer[n++]=+i;break;default:throw new Error(`FATAL: Invalid value for payload to worker: ${i}`)}a("Wrote",n*4,"bytes to buffer for event",r),Atomics.notify(this.sharedBuffer,0,1),a("Notified event",r,"to worker")}async waitForOneshotMessage(e){return new Promise(t=>{this.onOneshotMessage.set(e,t)})}encodeStringToBuffer(e,t){let r=t;const n=e.length;this.sharedBuffer[r++]=n;for(let i=0;i<n;++i)this.sharedBuffer[r++]=e.charCodeAt(i);return r}recvMessage(e){const t=e.data,r=this.onOneshotMessage.get(t.kind);if(r!==void 0){this.onOneshotMessage.delete(t.kind),r(t);return}this.onMessage(t)}recvError(e){a("Received an error from worker:",e);const t=`${e.message} (${e.filename}:${e.lineno}:${e.colno})`;this.onError(new Error(t))}}class ${constructor(e,t,r,n){this.canvas=r,this.worker=n,this.elemHeight=t,this.elemWidth=e;const i=window.devicePixelRatio||1;this.canvas.width=e*i,this.canvas.height=t*i,this.bounceTimerToken=null,this.onResize=this.onResize.bind(this)}onVimInit(){window.addEventListener("resize",this.onResize,{passive:!0})}onVimExit(){window.removeEventListener("resize",this.onResize)}doResize(){const e=this.canvas.getBoundingClientRect();a("Resize Vim:",e),this.elemWidth=e.width,this.elemHeight=e.height;const t=window.devicePixelRatio||1;this.canvas.width=e.width*t,this.canvas.height=e.height*t,this.worker.notifyResizeEvent(e.width,e.height)}onResize(){this.bounceTimerToken!==null&&window.clearTimeout(this.bounceTimerToken),this.bounceTimerToken=window.setTimeout(()=>{this.bounceTimerToken=null,this.doResize()},500)}}class Y{constructor(e,t){this.worker=e,this.elem=t,this.onKeydown=this.onKeydown.bind(this),this.onBlur=this.onBlur.bind(this),this.onFocus=this.onFocus.bind(this),this.focus()}setFont(e,t){this.elem.style.fontFamily=e,this.elem.style.fontSize=`${t}px`}focus(){this.elem.focus()}onVimInit(){this.elem.addEventListener("keydown",this.onKeydown,{capture:!0}),this.elem.addEventListener("blur",this.onBlur),this.elem.addEventListener("focus",this.onFocus)}onVimExit(){this.elem.removeEventListener("keydown",this.onKeydown),this.elem.removeEventListener("blur",this.onBlur),this.elem.removeEventListener("focus",this.onFocus)}onKeydown(e){e.preventDefault(),e.stopPropagation(),a("onKeydown():",e,e.key,e.keyCode);let t=e.key;const r=e.ctrlKey,n=e.shiftKey,i=e.altKey,s=e.metaKey;if(t.length>1&&(t==="Unidentified"||r&&t==="Control"||n&&t==="Shift"||i&&t==="Alt"||s&&t==="Meta")){a("Ignore key input",t);return}(t==="Â¥"||!n&&t==="|"&&e.code==="IntlYen")&&(t="\\"),this.worker.notifyKeyEvent(t,e.keyCode,r,n,i,s)}onFocus(){a("onFocus()")}onBlur(e){a("onBlur():",e),e.preventDefault()}}class K{constructor(e,t,r){this.worker=e,this.canvas=t;const n=this.canvas.getContext("2d",{alpha:!1});if(n===null)throw new Error("Cannot get 2D context for <canvas>");this.ctx=n;const i=this.canvas.getBoundingClientRect(),s=window.devicePixelRatio||1;this.canvas.width=i.width*s,this.canvas.height=i.height*s,this.canvas.addEventListener("click",this.onClick.bind(this),{capture:!0,passive:!0}),this.input=new Y(this.worker,r),this.resizer=new $(i.width,i.height,t,e),this.onAnimationFrame=this.onAnimationFrame.bind(this),this.queue=[],this.rafScheduled=!1,this.perf=!1,this.fgColor="",this.spColor="",this.fontName=""}onVimInit(){this.input.onVimInit(),this.resizer.onVimInit()}onVimExit(){this.input.onVimExit(),this.resizer.onVimExit()}draw(e){this.rafScheduled||(window.requestAnimationFrame(this.onAnimationFrame),this.rafScheduled=!0),this.queue.push(e)}focus(){this.input.focus()}getDomSize(){return{width:this.resizer.elemWidth,height:this.resizer.elemHeight}}setPerf(e){this.perf=e}setColorFG(e){this.fgColor=e}setColorBG(e){}setColorSP(e){this.spColor=e}setFont(e,t){this.fontName=e,this.input.setFont(e,t)}drawRect(e,t,r,n,i,s){const o=window.devicePixelRatio||1;e=Math.floor(e*o),t=Math.floor(t*o),r=Math.floor(r*o),n=Math.floor(n*o),this.ctx.fillStyle=i,s?this.ctx.fillRect(e,t,r,n):this.ctx.rect(e,t,r,n)}drawText(e,t,r,n,i,s,o,u,h,m){const d=window.devicePixelRatio||1;t=t*d,r=r*d,n=n*d,i=i*d,s=s*d;let g=`${Math.floor(t)}px ${this.fontName}`;o&&(g="bold "+g),this.ctx.font=g,this.ctx.textBaseline="bottom",this.ctx.fillStyle=this.fgColor;const E=(r-t)/2,b=Math.floor(s+r-E);for(let c=0;c<e.length;++c){const w=e[c];w!==" "&&this.ctx.fillText(w,Math.floor(i+n*c),b)}if(u){this.ctx.strokeStyle=this.fgColor,this.ctx.lineWidth=1*d,this.ctx.setLineDash([]),this.ctx.beginPath();const c=Math.floor(s+r-E-1*d);this.ctx.moveTo(Math.floor(i),c),this.ctx.lineTo(Math.floor(i+n*e.length),c),this.ctx.stroke()}else if(h){this.ctx.strokeStyle=this.spColor,this.ctx.lineWidth=1*d;const c=Math.floor(n/3);this.ctx.setLineDash([c,c]),this.ctx.beginPath();const w=Math.floor(s+r-E-1*d);this.ctx.moveTo(Math.floor(i),w),this.ctx.lineTo(Math.floor(i+n*e.length),w),this.ctx.stroke()}else if(m){this.ctx.strokeStyle=this.fgColor,this.ctx.lineWidth=1*d,this.ctx.beginPath();const c=Math.floor(s+r/2);this.ctx.moveTo(Math.floor(i),c),this.ctx.lineTo(Math.floor(i+n*e.length),c),this.ctx.stroke()}}invertRect(e,t,r,n){const i=window.devicePixelRatio||1;e=Math.floor(e*i),t=Math.floor(t*i),r=Math.floor(r*i),n=Math.floor(n*i);const s=this.ctx.getImageData(e,t,r,n),o=s.data,u=o.length;for(let h=0;h<u;++h)o[h]=255-o[h],++h,o[h]=255-o[h],++h,o[h]=255-o[h],++h;this.ctx.putImageData(s,e,t)}imageScroll(e,t,r,n,i){const s=window.devicePixelRatio||1;e=Math.floor(e*s),t=Math.floor(t*s),r=Math.floor(r*s),n=Math.floor(n*s),i=Math.floor(i*s),this.ctx.drawImage(this.canvas,e,t,n,i,e,r,n,i)}onClick(){this.input.focus()}onAnimationFrame(){a("Rendering",this.queue.length,"events on animation frame"),this.perfMark("raf");for(const[e,t]of this.queue)this.perfMark("draw"),this[e].apply(this,t),this.perfMeasure("draw",`draw:${e}`);this.queue.length=0,this.rafScheduled=!1,this.perfMeasure("raf")}perfMark(e){this.perf&&performance.mark(e)}perfMeasure(e,t){this.perf&&(performance.measure(t??e,e),performance.clearMarks(e))}}class J{constructor(e){const t=e.workerScriptPath;if(!t)throw new Error("'workerScriptPath' option is required");if(this.handleError=this.handleError.bind(this),this.worker=new W(t,this.onMessage.bind(this),this.handleError),"canvas"in e&&"input"in e)this.screen=new K(this.worker,e.canvas,e.input);else if("screen"in e)this.screen=e.screen;else throw new Error("Invalid options for VimWasm construction: "+JSON.stringify(e));this.perf=!1,this.debug=!1,this.perfMessages={},this.running=!1,this.end=!1}start(e){var t,r,n,i,s;if(this.running||this.end)throw new Error("Cannot start Vim twice");const o=e??{clipboard:navigator.clipboard!==void 0};o.debug&&(a=console.log.bind(console,"main:"),this.worker.debug=!0),this.perf=!!o.perf,this.debug=!!o.debug,this.screen.setPerf(this.perf),this.running=!0,this.perfMark("init");const{width:u,height:h}=this.screen.getDomSize(),m={kind:"start",buffer:this.worker.sharedBuffer,canvasDomWidth:u,canvasDomHeight:h,debug:this.debug,perf:this.perf,clipboard:!!o.clipboard,files:(t=o.files,t??{}),dirs:(r=o.dirs,r??[]),fetchFiles:(n=o.fetchFiles,n??{}),persistent:(i=o.persistentDirs,i??[]),cmdArgs:(s=o.cmdArgs,s??[])};this.worker.sendStartMessage(m),a("Started with drawer",this.screen)}async dropFile(e,t){if(!this.running)throw new Error("Cannot open file since Vim is not running");a("Handling to open file",e,t);const[r,n]=await this.worker.requestSharedBuffer(t.byteLength);new Uint8Array(n).set(new Uint8Array(t)),this.worker.notifyOpenFileBufComplete(e,r),a("Wrote file",e,"to",t.byteLength,"bytes buffer and notified it to worker")}async dropFiles(e){const t=new FileReader;for(const r of e){const[n,i]=await this.readFile(t,r);await this.dropFile(n,i)}}resize(e,t){this.worker.notifyResizeEvent(e,t)}sendKeydown(e,t,r){const{ctrl:n=!1,shift:i=!1,alt:s=!1,meta:o=!1}=r??{};if(e.length>1&&(e==="Unidentified"||n&&e==="Control"||i&&e==="Shift"||s&&e==="Alt"||o&&e==="Meta")){a("Ignore key input",e);return}this.worker.notifyKeyEvent(e,t,n,i,s,o)}cmdline(e){return this.worker.requestCmdline(e)}isRunning(){return this.running}focus(){this.screen.focus()}showError(e){return this.worker.notifyErrorOutput(e)}async readFile(e,t){return new Promise((r,n)=>{e.onload=i=>{a("Read file",t.name,"from D&D:",i),r([t.name,e.result])},e.onerror=()=>{e.abort(),n(new Error(`Error on loading file ${t}`))},e.readAsArrayBuffer(t)})}async evalJS(e,t){a("Evaluating JavaScript file",e,"with size",t.byteLength,"bytes");const n='"use strict";'+new TextDecoder().decode(t);try{Function(n)()}catch(i){a("Failed to evaluate",e,"with error:",i),await this.showError(`${i.message}

${i.stack}`)}}async evalFunc(e,t,r){a("Evaluating JavaScript function:",e,t);let n;try{n=new q(e)}catch(o){return this.worker.notifyEvalFuncError("Could not construct function",o,r)}let i;try{i=await n(...t)}catch(o){return this.worker.notifyEvalFuncError("Exception was thrown while evaluating function",o,r)}if(r)return a("Evaluated JavaScript result was discarded since the message was notify-only:",i,e),Promise.resolve();let s;try{s=JSON.stringify(i)}catch(o){return this.worker.notifyEvalFuncError("Could not serialize return value as JSON from function",o,!1)}return this.worker.notifyEvalFuncRet(s)}onMessage(e){if(this.perf&&e.timestamp!==void 0){const t=Date.now()-e.timestamp,r=e.kind==="draw"?`draw:${e.event[0]}`:e.kind;this.perfMessages[r]===void 0?this.perfMessages[r]=[t]:this.perfMessages[r].push(t)}switch(e.kind){case"draw":this.screen.draw(e.event),a("draw event",e.event);break;case"done":this.worker.onEventDone(e.status);break;case"evalfunc":{const t=e.argsJson===void 0?[]:JSON.parse(e.argsJson);this.evalFunc(e.body,t,e.notifyOnly).catch(this.handleError);break}case"title":this.onTitleUpdate&&(a("title was updated:",e.title),this.onTitleUpdate(e.title));break;case"read-clipboard:request":this.readClipboard?this.readClipboard().then(t=>this.worker.responseClipboardText(t)).catch(t=>{a("Cannot read clipboard:",t),this.worker.notifyClipboardError()}):(a("Cannot read clipboard because VimWasm.readClipboard is not set"),this.worker.notifyClipboardError());break;case"write-clipboard":a("Handle writing text",e.text,"to clipboard with",this.onWriteClipboard),this.onWriteClipboard&&this.onWriteClipboard(e.text);break;case"export":this.onFileExport!==void 0&&(a("Exporting file",e.path,"with size in bytes",e.contents.byteLength),this.onFileExport(e.path,e.contents));break;case"eval":this.evalJS(e.path,e.contents).catch(this.handleError);break;case"started":this.screen.onVimInit(),this.onVimInit&&this.onVimInit(),this.perfMeasure("init"),a("Vim started");break;case"exit":this.screen.onVimExit(),this.printPerfs(),this.worker.terminate(),this.onVimExit&&this.onVimExit(e.status),a("Vim exited with status",e.status),this.perf=!1,this.debug=!1,this.screen.setPerf(!1),this.running=!1,this.end=!0;break;case"error":a("Vim threw an error:",e.message),this.handleError(new Error(e.message)),this.worker.terminate();break;default:throw new Error(`Unexpected message from worker: ${JSON.stringify(e)}`)}}handleError(e){this.onError&&this.onError(e)}printPerfs(){if(this.perf){{const e=new Map;for(const i of performance.getEntries()){const s=e.get(i.name);s===void 0?e.set(i.name,[i]):s.push(i)}const t={},r={},n=[];for(const[i,s]of e){if(s.length===1&&s[0].entryType!=="measure"){n.push(s[0]);continue}console.log(`%c${i}`,"color: green; font-size: large"),console.table(s,["duration","startTime"]);const o=s.reduce((u,h)=>u+h.duration,0);t[i]=o/s.length,r[i]=o}console.log("%cTimings (ms)","color: green; font-size: large"),console.table(n,["name","entryType","startTime","duration"]),console.log("%cAmount: Perf Mark Durations (ms)","color: green; font-size: large"),console.table(r),console.log("%cAverage: Perf Mark Durations (ms)","color: green; font-size: large"),console.table(t),performance.clearMarks(),performance.clearMeasures()}{const e={};for(const t of Object.keys(this.perfMessages)){const r=this.perfMessages[t],n=r.reduce((i,s)=>i+s,0);e[t]=n/r.length}console.log("%cAverage: Inter-thread Messages Duration (ms)","color: green; font-size: large"),console.table(e),this.perfMessages={}}}}perfMark(e){this.perf&&performance.mark(e)}perfMeasure(e){this.perf&&(performance.measure(e,e),performance.clearMarks(e))}}function H({worker:l,drawer:e,debug:t,perf:r,clipboard:n,onVimExit:i,onVimInit:s,onFileExport:o,readClipboard:u,onWriteClipboard:h,onError:m,onTitleUpdate:d,files:g,fetchFiles:E,dirs:b,persistentDirs:c,cmdArgs:w,onVimCreated:R}){const v=k.useRef(null),F=k.useRef(null),[_,U]=k.useState(null);return k.useEffect(()=>{const N=e!==void 0?{workerScriptPath:l,screen:e}:{workerScriptPath:l,canvas:v.current,input:F.current},f=new J(N);return f.onVimInit=s,f.onVimExit=i,f.onFileExport=o,f.readClipboard=u,f.onWriteClipboard=h,f.onTitleUpdate=d,f.onError=m,v.current!==null&&(v.current.addEventListener("dragover",p=>{p.stopPropagation(),p.preventDefault(),p.dataTransfer&&(p.dataTransfer.dropEffect="copy")},!1),v.current.addEventListener("drop",p=>{p.stopPropagation(),p.preventDefault(),p.dataTransfer&&f.dropFiles(p.dataTransfer.files).catch(m)},!1)),R!==void 0&&R(f),f.start({debug:t,perf:r,clipboard:n,files:g,fetchFiles:E,dirs:b,persistentDirs:c,cmdArgs:w}),U(f),()=>{f.isRunning()&&f.cmdline("qall!")}},[l,t,r,n,g,b,c,w]),e!==void 0?[null,null,_]:[v,F,_]}const j=""+new URL("vim-b27d49a7.js",import.meta.url).href,Q="_input_rzztm_1",G="_container_rzztm_11",Z="_canvas_rzztm_14",S={input:Q,container:G,canvas:Z};function ee(){const[l,e,t]=H({worker:j}),[r,n]=y.useState(500),[i,s]=y.useState(500),o=y.useRef(null);return y.useEffect(()=>{const u=o.current;if(!u)return;const h=u.getBoundingClientRect();n(h.width),s(h.width)},[]),V("div",{className:S.container,ref:o,children:[C("canvas",{className:S.canvas,ref:l}),C("input",{className:S.input,ref:e})]})}export{ee as default};
